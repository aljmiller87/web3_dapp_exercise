/* Geth
 * =====
 * Application developed against Geth/ROPSTEN
 * 
 * TestRPC
 * =======
 * Some API NOT Supported in TestRPC
 * Etherscan.io links will not be supported for TestRPC
 * 
 * META MASK
 * =========
 * MetaMask will work - except some for some functions coded SYNCHRONOUSLY
 * You may change it to work with MetaMask
 * 
 */


 // UI JS
 $('article').not('.connect').addClass('hidden');

 $('.account-button').click(function() {
    $('article').addClass('hidden');
    $('article.account').removeClass('hidden');
 });

 $('.connect-button').click(function() {
    $('article').addClass('hidden');
    $('article.connect').removeClass('hidden');
 })

 $('.deploy-button').click(function() {
    $('article').addClass('hidden');
    $('article.deploy').removeClass('hidden');
 })

 $('.interact-button').click(function() {
    $('article').addClass('hidden');
    $('article.interact').removeClass('hidden');
 })


// ********* BLOCKCHAIN CONNECTION **************

// The sample code was compiled in Remix
// Bytecode / Interface generated by Remix was pasted here
var contract_abidefinition = '[{"constant":false,"inputs":[],"name":"getNum","outputs":[{"name":"n","type":"uint256"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"n","type":"uint256"}],"name":"setNum","outputs":[],"payable":false,"type":"function"},{"inputs":[{"name":"x","type":"uint256"}],"payable":false,"type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"caller","type":"address"},{"indexed":true,"name":"oldNum","type":"bytes32"},{"indexed":true,"name":"newNum","type":"bytes32"}],"name":"NumberSetEvent","type":"event"}]';
var contract_bytecode = '0x6060604052341561000c57fe5b604051602080610168833981016040528080519060200190919050505b806000819055505b505b610126806100426000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806367e0badb146044578063cd16ecbf146067575bfe5b3415604b57fe5b60516084565b6040518082815260200191505060405180910390f35b3415606e57fe5b60826004808035906020019091905050608f565b005b600060005490505b90565b60006000549050816000819055506000546001026000191681600102600019163373ffffffffffffffffffffffffffffffffffffffff167f108fd0bf2253f6baf35f111ba80fb5369c2e004b88e36ac8486fcee0c87e61ce60405180905060405180910390a45b50505600a165627a7a72305820b86215323334042910c2707668d7cc3c3ec760d2f5962724042482293eba5f6b0029';

// If autoRetrieveFlag is true, it will: auto connect, get accounts, set UI components, get balances
var autoRetrieveFlag = true;

// Holds the accounts
var accounts;

// Holds the filter objects
var filterWatch;
var filterEventCounter;

// Holds the contract event object
var contractEvent;
var contractEventCounter=0;

// Maintains the info on node type
var     nodeType = 'geth';// If autoRetrieveFlag is true, it will: auto connect, get accounts, set UI components, get balances
var autoRetrieveFlag = true;


// Connecting to the node

window.addEventListener('load', function() {

  // Checking if Web3 has been injected by the browser (Mist/MetaMask)
  if (typeof web3 !== 'undefined') {
    // Use Mist/MetaMask's provider
    window.web3 = new Web3(web3.currentProvider);
  } else {
    console.log('Injected web3 Not Found!!!')
    // fallback - use your fallback strategy (local node / hosted node + in-dapp id mgmt / fail)
    var provider = $('.connect .set-up input[type=text]').val();
    window.web3 = new Web3(new Web3.providers.HttpProvider(provider));
    // window.web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:8545'));
  }

  // Now you can start your app & access web3 freely:
  startApp()

})

function startApp(){

    // If the app is reconnected we should reset the watch
    doFilterStopWatching();
    doContractEventWatchStop();

    // Set the connect status on the app
    if (web3 && web3.isConnected()) {
        $('.connect .set-up p span').removeClass('not-ready').addClass('ready').text("Connected");
        // Gets the version data and populates the result UI
        setWeb3Version();

    } else {
        // setData('connect_status','Not Connected', true);
        $('.connect .set-up p span').removeClass('ready').addClass('not-ready').text("Not Connected");
    }

    // no action to be taken if this flag is OFF  
    // during development for convinience you may set autoRetrieveFlag=true
    if(!autoRetrieveFlag)  return;



    doGetAccounts();
    doGetNodeStatus();
    getMiningStatus();
    getSyncingStatus();

    // Compilation is available only for TestRPC
    // Geth 1.6 and above does not support compilation
    // MetaMask does not support compilation
    // doGetCompilers();
}

function doConnect()    {

    // Get the provider URL
    var provider = $('.connect .set-up input[type=text]').val();
    window.web3 = new Web3(new Web3.providers.HttpProvider(provider));
    startApp();

}


/**
 * Get the version information for Web3
 */

function setWeb3Version() {

    var versionJson = {};

    // Asynchronous version
    web3.version.getNode(function(error, result){
        if(error) {
        	$('.version p').removeClass('ready').addClass('not-ready').text(error.message);
        } else {
            $('.version p').addClass('ready').text(result);

            if(result.toLowerCase().includes('metamask')){
                nodeType = 'metamask';
                $('.node-type p').addClass('ready').text(nodeType);
            } else if(result.toLowerCase().includes('testrpc')){
                nodeType = 'testrpc';
                $('.node-type p').addClass('ready').text(nodeType);
            } else {
                nodeType = 'geth';
                $('.node-type p').addClass('ready').text(nodeType);
            }

            
            // set up UI elements based on the node type
            // setUIBasedOnNodeType();
        }
    });
}

/**
 * Stop watching for events
 */

function doFilterStopWatching()  {

    // 1. Stop watching if watching iactive
    if(filterWatch){
        filterWatch.stopWatching();
        filterWatch = undefined;
    }
    // 2. Reset the UI
    // document.getElementById('applied_watch_filter').value='';

    // 3. Remove all of the past events from the list
    // clearList('watch_events_list');

    // 4. reset the counter
    filterEventCounter = 0;
}

/**
 * To stop the event watching using the contract object
 */

function doContractEventWatchStop()   {

    if(contractEvent){
        contractEvent.stopWatching();
        contractEvent = undefined;
    }
    contractEventCounter = 0;
    // clearList('watch_contract_events_list');
    // setData('watch_contract_instance_event_count', '---', true);
}

/**
 * Uses the web3.net status to check if the client is listening and peer count
 */

function doGetNodeStatus()  {

    // Asynch version
    web3.net.getListening(function(error, result){
        if(error) {
            $('.node-status span').addClass('not-ready').removeClass('ready').text(error.message);
        } else {
            // Since connected lets get the count
            web3.net.getPeerCount(  function(  error,  result ) {
            if(error){
                $('.node-status span').addClass('not-ready').removeClass('ready').text("No Peers.");
            } else {
                $('.node-status span').addClass('ready').removeClass('not-ready').text(result,(result == 0));
            }
        });
        }
    });
}

function getMiningStatus() {
    // Asynch
    web3.eth.getMining(function(error, result) {
        if(error) console.log('Mining Status error: ', error.message);
        else {
            console.log('Mining Status: ', result);
        }
    })
}

function getSyncingStatus() {
    // Asynch
    web3.eth.getSyncing(function(error, result) {
        if(error) console.log('Syncing Status Error: ', error.message);
        else {
            console.log('Syncing Status: ', result);
            const width = (result.currentBlock/result.highestBlock*100).toFixed(2);
            $('.progress-bar').css("width", `${width}%`);
            $('.progress-bar').text(`${width}%`);
        }
    })
}


// Event Listeners
$('.blockchain-connect').click(function() {
    // console.log('test');
    $('.connect .set-up span').html('');
    doConnect();
})

$('.get-node-status').click(function() {
    $('.node-status span').html('');
    doGetNodeStatus();
})

// ******************************************************

// ********* Account Related **************
function    doGetAccounts() {
    // This is the synch call for getting the accounts
    var accounts = web3.eth.accounts
    
    // Asynchronous call to get the accounts
    // result = [Array of accounts]
    // MetaMask returns 1 account in the array - that is the currently selected account
    web3.eth.getAccounts(function (error, result) {
        if (error) {
            console.log('Accounts error: ', error.message);
        } else {
            accounts = result;
            console.log('accounts_count: ', result.length);
            // You need to have at least 1 account to proceed
            if(result.length == 0) {
                if(nodeType == 'metamask'){
                    alert('Unlock MetaMask *and* click \'Get Accounts\'');
                }
                return;
            }



            // This populates the SELECT boxes with the accounts
            renderAccountsAndBalances(accounts);
            
            // var coinbase = web3.eth.coinbase;
            // trim it so as to fit in the window/UI
            // if(coinbase) coinbase = coinbase.substring(0,25)+'...'
            // setData('coinbase', coinbase, false);
            // set the default accounts
            var defaultAccount = web3.eth.defaultAccount;
            if(!defaultAccount){
                web3.eth.defaultAccount =  result[0];
                defaultAccount = '[Undef]' + result[0];
            }

            defaultAccount = defaultAccount.substring(0,25)+'...';
            console.log('defaultAccount', defaultAccount);
        }
        
    });
}

const getBalancePromised = account => new Promise((resolve, reject) => {
    web3.eth.getBalance(account, web3.eth.defaultBlock, (error, result) => {
      if(error){
        return reject(error)
      }
      const balance = web3.fromWei(result, 'ether').toFixed(4)
      resolve(balance)
    })
})

async function renderAccountsAndBalances(accounts) {  
  for(const account of accounts) {
    const balance = await getBalancePromised(account)
    
    const row = `<tr><td> ${account} </td><td> ${balance} </td></tr>`;
    const option = `<option> ${account} </option>`;
    $('.account .table tbody').append(row)
    $('.account .account-select').append(option);
    $('.account .from-account').append(option);
    $('.account .to-account').append(option);
    $('.interact select').append(option);
  }
}

function unlockAccount() {
    const account = $('.account .account-select').val();
    const password = $('.account .account-password').val();
    web3.personal.unlockAccount(account, password, function(error, result) {
        if(error) {
            $('.account .lock-unlock-result').addClass('not-ready').removeClass('ready').html(error.message);
        } else if (result) {
            $('.account .lock-unlock-result').addClass('ready').removeClass('not-ready').html(`Account ${account} is unlocked`);
        }

    })
}

function lockAccount() {
    var account = $('.account-select').val();
    web3.personal.lockAccount(account);
    $('.account .lock-unlock-result').addClass('not-ready').removeClass('ready').html(`Account ${account} is locked`);
}

function createTransactionObjectJSON() {
    var txnObject = {};
    // get the from and to account 
    txnObject.from = $('.transaction-object .from-account').val();
    txnObject.to = $('.transaction-object .to-account').val();
    // Get the value in ether and convert to wie
    var valueInEther = $('.transaction-object .value').val();
    var valueInWei = web3.toWei(valueInEther,'ether');
    txnObject.value = valueInWei;
    // set the gas and gasPrice
    if($('.transaction-object .gas').val() !== 'default')
        txnObject.gas = $('.transaction-object .gas').val();
    if($('.transaction-object .gas-price').val() !== 'default')
        txnObject.gasPrice = $('.transaction-object .gas-price').val();
    // set the data
    if($('.transaction-object .data').val() !== 'default'){
        // convert the ascii to hex
        var data = $('.transaction-object .data').val();
        txnObject.data = web3.toHex(data);
    }
    // set the nonce
    if($('.transaction-object .nonce').val() !== 'default')
        txnObject.nonce = $('.transaction-object .nonce').val();


    return txnObject;
}

function transactionObjectJSON() {
    const txnObject = createTransactionObjectJSON();
    const txnJSON = JSON.stringify(txnObject,undefined,4);
    $('.transaction-json').addClass('ready').html(txnJSON);
    return txnJSON;
}

function resetTransactionObject() {
    $(".transaction-object .from-account").prop("selectedIndex", 0);
    $(".transaction-object .to-account").prop("selectedIndex", 0);
    $('.transaction-object .value').val('0');
    $('.transaction-object .gas').val('default');
    $('.transaction-object .gas-price').val('default');
    $('.transaction-object .data').val('default');
    $('.transaction-object .nonce').val('default');
}

function doSendTransaction() {
    const txnObject = createTransactionObjectJSON();
    web3.eth.sendTransaction(txnObject, function(error, result) {
        if (error) {
            $('.account .send-transaction-result').addClass('not-ready').removeClass('ready').html(error.message);
        } else {
            $('.account .send-transaction-result').addClass('ready').removeClass('not-ready').text(`Transaction hash: ${result}`);
            $('.account .transaction-link').html(`<a href="https://rinkeby.etherscan.io/tx/${result}">Etherscan Link</a>`);
        }
    })
}


// Event Listeners
$('.account .unlock-account').click(function() {
    unlockAccount();
})

$('.account .lock-account').click(function() {
    lockAccount();
})

$('.account .create-json').click(function() {
    transactionObjectJSON();
})

$('.account .transaction-reset').click(function() {
    resetTransactionObject();
})

$('.account .transaction-send').click(function() {
    doSendTransaction();
})


// ***** DEPLOY ********************
function doDeployContract() {
// var contract_abidefinition = '[{"constant":false,"inputs":[],"name":"getNum","outputs":[{"name":"n","type":"uint256"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"n","type":"uint256"}],"name":"setNum","outputs":[],"payable":false,"type":"function"},{"inputs":[{"name":"x","type":"uint256"}],"payable":false,"type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"caller","type":"address"},{"indexed":true,"name":"oldNum","type":"bytes32"},{"indexed":true,"name":"newNum","type":"bytes32"}],"name":"NumberSetEvent","type":"event"}]';
// var contract_bytecode = '0x6060604052341561000c57fe5b604051602080610168833981016040528080519060200190919050505b806000819055505b505b610126806100426000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806367e0badb146044578063cd16ecbf146067575bfe5b3415604b57fe5b60516084565b6040518082815260200191505060405180910390f35b3415606e57fe5b60826004808035906020019091905050608f565b005b600060005490505b90565b60006000549050816000819055506000546001026000191681600102600019163373ffffffffffffffffffffffffffffffffffffffff167f108fd0bf2253f6baf35f111ba80fb5369c2e004b88e36ac8486fcee0c87e61ce60405180905060405180910390a45b50505600a165627a7a72305820b86215323334042910c2707668d7cc3c3ec760d2f5962724042482293eba5f6b0029';

    const byteCode = $('textarea.bytecode').val();
    const abiDefinitionString = $('textarea.ABI').val();
    const abiDefinition = JSON.parse(abiDefinitionString);

    // 1. Create the contract object
    const  contract = web3.eth.contract(abiDefinition);

    // Get the estimated gas
    const   gas = $('.contract .gas').val();

    // 2. Create the params for deployment - all other params are optional, uses default
    const  params = {
        from: web3.eth.accounts[0],
        data: byteCode,
        gas: gas
    }


    // 3. This is where the contract gets deployed
    // Callback method gets called *2* 
    // First time : Result = Txn Hash
    // Second time: Result = Contract Address
    let constructor_param = 10;

    contract.new(constructor_param,params,function(error,result){

        if(error){
            console.log(error.message);            
            // $('.transaction-address').text(error.message + " (Checking Synchronously)");
            const transactionHash = $('.transaction-hash').text();
            web3.eth.getTransactionReceipt(transactionHash, function(error, result){
                if(error) console.log('SENDTran Error=', error)
                else   if(result) console.log('SENDTran Hash=', result);
            });
        } else {
            console.log('RECV:',result)
            if(result.address){
                $('.blockchain').text(result.address);
                $('.address-etherscan').html('<a href="https://rinkeby.etherscan.io/tx/' + result.address + '">Etherscan Link</a>');
            } else {
                // gets set in the first call
                $('.transaction-hash').html('<p>'+ result.transactionHash + '</p>');
                $('.transaction-etherscan').html('<a href="https://rinkeby.etherscan.io/tx/' + result.transactionHash + '">Etherscan Link</a>');
            }
        }
    });
}

//Event Listeners
$('.deploy-contract').click(function() {
    doDeployContract();
})


//****************************

// INTERACT

// utility method to create contract instance
function createContractInstance(addr) {
    const abiDefinitionString = $('textarea.ABI').val();
    const abiDefinition = JSON.parse(abiDefinitionString);

    // 1. Create the contract object
    const  contract = web3.eth.contract(abiDefinition);
    let address = addr;
    if (!addr) {
        address = $('.blockchain').text();
    }

    console.log('address', address);
    // if (!addr) {
    //     address = '0xc4fAa1Ed4A7519E9420A5a2E8A7A49AdE9b06467';
    // }
    
    const instance = contract.at(address);
    console.log('instance', instance);
    return instance

}

function    doContractFunctionCall()  {
    // This leads to the invocation of the method locally
    const instance = createContractInstance();
    const message = $('.interact input[type=text').val();

    // MetaMask does not allow synchronous call to 'call' for non-constant function
    // Change this to asynchronous :)
    var value = instance.interact.call(message, function(error, result) {
        if(error) {
            console.log("Call error: ", error);
        } else {
            console.log("Call result: ", result)
        }
    });

}

/**
 * send Transaction costs Gas. State changes are recorded on the chain.
 */
function    doContractSendCall()   {
    // creating the cntract instance
    const instance = createContractInstance();
    // read the ui elements
    const estimatedGas = $('.interact').find('.gas').val();
    const fromAccount = $('.interact select').val();
    const message = $('.interact input[type=text').val();

    console.log(fromAccount, message);

    // Create the transaction object
    var    txnObject = {
        from: fromAccount,
        gas: estimatedGas
    }

    // Interact with sendTransaction
    instance.interact.sendTransaction(message,txnObject,function(error, result)  {

        console.log('RECVED>>',error,result);   
        if(error){
            // setExecuteResultUI('Send Transaction:   ',funcName,'',error,'',true);
            console.log(error);
            $('.call-send-result').removeClass('ready').addClass('not-ready').text('Call error: ' + error.message);
        } else {
            // setExecuteResultUI('Send Transaction:   ',funcName,parameterValue,result,result,false);
            $('.call-send-result').removeClass('ready').addClass('not-ready').text('Call result: ' + result);
            console.log(result);
        }
    });
        
}

function doFilterWatchStart () {
    //1. Stop the wtach if its already ON
    doFilterStopWatching();
    //2. Reset the UI
    $('.event-count').text('0');

    //3. Create the filter option
    var options = generateFilterOptions("latest");
    console.log('FILTER Watch Options:', JSON.stringify(options));

    //4. Create instance of the filter
    filterWatch = web3.eth.filter(options);
    console.log('filterWatch', filterWatch);

    //5. Now start watching
    filterWatch.watch(function(error,result){
        if(error){
            console.error('Filter Watch Error: ',error);
        } else {
            filterEventCounter++;
            console.log(filterEventCounter, result);
            // Update the UI for the counter
            const message = web3.toAscii(result.topics[1]);
            const address = web3.toDecimal(result.topics[2]);
            const time = web3.toDecimal(result.topics[3]);
            $('.interact table tbody').append(`<tr><td>${message}</td><td>${address}</td><td>${time}</td><tr>`);
        }
    });
}

function doFilterStopWatching() {
    // 1. Stop watching if watching iactive
    if(filterWatch){
        filterWatch.stopWatching();
        filterWatch = undefined;
    }
    // 2. Reset the UI
    $('.watchEventCount').text('Not Watching');
    $('.event-log-filter .appliedWatchFilter').val('');

    // 3. Remove all of the past events from the list
    // clearList('watch_events_list');

    // 4. reset the counter
    filterEventCounter = 0;
}

/**
 * Generates the filter options array & updates the UI also
 */

function    generateFilterOptions(latest)   {

    let options = {};
    let val = '1';
    if(latest) {
        console.log('found ', latest);
        options['fromBlock'] = "latest";
    } else {
        options['fromBlock'] = "1";
    }
                
    val = '';
    if(val && val.trim().length > 0)
                options['toBlock'] =  val;

    val = $('.contract .blockchain').text();
    console.log('found address: ', val);
    // Addresses have multiple addresses separated by new line - need to be changed to comma separated
    val = val.trim();
    
    if(val.length > 0) {
        //val = val.replace('\n',',');
        val = val.split('\n');
        options['address'] = val;
    }

    console.log(JSON.stringify(options,undefined,2));
    return options;
}

/**
 * Get the logs for the specified filter
 * Testnet sample contract address: 
 */

function    doFilterGetLogs()  {

    // 1. Clear the list
    $('.interact table tr').not(':first').remove();
    $('.log-error').remove();
    
    // 2. Create the filter option
    var options = generateFilterOptions();
    console.log('FILTER Get Options:', JSON.stringify(options));

    // 3. Create the instance of the filter
    var filterGet = web3.eth.filter(options);

    // 4. Invoke get on filter with the callback function
    filterGet.get(function(error, result){
        if(error){
            console.log('GET Error:',error);
            $('.interact table').before(`<p class="log-error">${error.message}</p>`);
            // setData('get_log_count',error, true);
        } else {
            console.log('get logs result', result);
            // result = array of events
            // Update UI with the data received as an array of events
            // setData('get_log_count',result.length, false);
            for(var i = 0; i < result.length ; i++){
                console.log("Event.watch="+JSON.stringify(result[i]))
                const message = web3.toAscii(result[i].topics[1]);
                const address = web3.toDecimal(result[i].topics[2]);
                const time = web3.toDecimal(result[i].topics[3]);
                $('.interact table tbody').append(`<tr><td>${message}</td><td>${address}</td><td>${time}</td><tr>`);
            }
        }
    });
}

// Event Listeners

$('.call-interaction').click(function() {
    doContractFunctionCall();
})

$('.send-interaction').click(function() {
    doContractSendCall();
})
$('.interact .get-logs').click(function() {
    doFilterGetLogs();
})

$('.interact .watch').click(function() {
    doFilterWatchStart();
})

$('.interact .stop-watch').click(function() {
    doFilterStopWatching();
})



